# RAPH-LOOP v3.0 Cursor Rules
# Full-Stack Web Development Stability & Session Management Protocols

## ğŸ¯ Core Principle
When fixing Full-Stack Web Development issues, ALWAYS follow the **Framework-Aware Debugging** and **Session Trace Protocol** before applying code changes.

---

## ğŸ“‹ 1. FRAMEWORK-AWARE DEBUGGING PROTOCOL

### When to Activate
Trigger this protocol when:
- User reports: "Login broken", "Session not updating", "Auth failing"
- Issue keywords: `Session`, `Auth`, `Login`, `State`, `Cookie`, `Header`
- Components involved: Authentication, Authorization, Middleware chains

### Framework Detection
```
IF code mentions NextAuth OR has pages/api/auth/ â†’ NEXTAUTH
IF code mentions express OR app.use() â†’ EXPRESS
IF code mentions @nestjs OR @Injectable â†’ NESTJS
IF code mentions FastAPI OR @app.route â†’ FASTAPI
IF code mentions Django OR views.py â†’ DJANGO
IF code mentions @SpringBoot OR @RestController â†’ SPRING
IF code mentions Laravel OR Route:: â†’ LARAVEL
```

### Mandatory Steps (Do NOT skip)

#### Step 1: IDENTIFY THE FRAMEWORK
```typescript
// Read: package.json, imports, decorators, middleware files
// Action: Determine framework and version
// Output: Framework name, version, key files
```

#### Step 2: VERIFY THE MIDDLEWARE CHAIN
```typescript
// For NextAuth: Check [...nextauth].ts/js
// For Express: Check app.use() order and middleware stack
// For NestJS: Check Module decorators and guards
// For FastAPI: Check dependencies and middleware order

// Verify:
// - Middleware is in CORRECT ORDER (auth before protected routes)
// - Middleware returns proper response/error
// - Session created BEFORE used in subsequent middleware
```

#### Step 3: VERIFY STORAGE PERSISTENCE
```typescript
// Check HOW session is stored:
// IF cookies â†’ Verify httpOnly, secure, sameSite flags
// IF localStorage â†’ Verify data survives page refresh
// IF sessionStorage â†’ Verify cleared on tab close
// IF JWT â†’ Verify token in Authorization header
// IF Redis/DB â†’ Verify backend store configured

// Action: DO NOT just add credentials, verify the STORAGE mechanism
```

---

## ğŸ“‹ 2. SESSION TRACE PROTOCOL

**MANDATORY**: When user reports session issues, execute this 3-step verification:

### Step A: Backend Verification
```
Question: "Is the API returning the user object?"

Verify:
âœ“ /api/auth/me endpoint exists
âœ“ Returns { user: {...}, token?: ... } structure
âœ“ User object contains: id, email, role, name
âœ“ No server errors (500, 503)
âœ“ Response time < 500ms

If FAIL:
  â†’ Backend must return complete user object
  â†’ Check authentication logic
  â†’ Verify database query for current user
  
If PASS:
  â†’ Continue to Step B
```

### Step B: Network Verification
```
Question: "Are cookies/headers being sent in requests?"

Verify:
âœ“ Fetch/Axios includes credentials: 'include' or headers
âœ“ Cookies set with httpOnly flag (can't access via JS)
âœ“ Authorization header sent as: "Bearer <token>"
âœ“ CORS allows credentials (Access-Control-Allow-Credentials: true)
âœ“ Network tab shows Cookie/Authorization headers in both Request & Response

If FAIL:
  â†’ Must configure credentials in ALL API calls
  â†’ Fetch: { credentials: 'include' }
  â†’ Axios: { withCredentials: true }
  
If PASS:
  â†’ Continue to Step C
```

### Step C: Frontend Verification
```
Question: "Is the Global Store receiving and persisting the session?"

Verify:
âœ“ State management exists (Context API / Redux / Zustand)
âœ“ Auth context/store subscribes to API response
âœ“ User state updates immediately after login
âœ“ User state persists on page refresh
âœ“ User state clears on logout
âœ“ Components receive updated state via hooks/selectors

If FAIL:
  â†’ State management must be connected to backend
  â†’ useAuth(), useSelector(), or useStore() must return live data
  â†’ Add localStorage/sessionStorage persistence layer
  
If PASS:
  â†’ Session management is working
```

---

## ğŸ“‹ 3. AST-SAFE UI REFACTORING PROTOCOL

### When to Activate
Trigger when fixing:
- React/Vue component rendering issues
- Hook dependency array warnings
- State management bugs in UI components
- Hydration mismatches (Next.js SSR)

### Rule: NEVER USE SIMPLE STRING REPLACEMENT

âŒ **WRONG** (Breaks surrounding code):
```typescript
// Original
const [user, setUser] = useState(null);
const [data, setData] = useState([]);

// Attempted fix with string replace:
const [userData, setUserData] = useState(null);  // â† Breaks other setUser() calls!
```

âœ… **RIGHT** (Surgical AST-aware fix):
```typescript
// 1. Locate the EXACT hook line
// 2. Understand all references to 'user'
// 3. Update:
//    a) Hook declaration
//    b) All setUser() calls
//    c) All references in JSX/callbacks
```

### Surgical Modification Steps

#### For useState/useEffect Hooks:
```
Step 1: Find the hook on specific line
Step 2: Check dependency array (if useEffect)
Step 3: Verify no stale closures
Step 4: Update ONLY the hook logic
Step 5: Run TypeScript check to verify types
```

#### For Render Blocks:
```
Step 1: Locate return statement / JSX block
Step 2: Identify condition (if conditional render)
Step 3: Find the EXACT location to modify
Step 4: Inject loading state or fallback UI
Step 5: Verify closing tags match
```

#### For Component State Updates:
```
Step 1: Find setUser/setState call
Step 2: Understand data structure
Step 3: Verify Redux action/Context dispatch
Step 4: Check if UI subscribes to change
Step 5: Test state update propagates to render
```

---

## ğŸ“‹ 4. SESSION TRACE TEST GENERATION

### Auto-Generate Test Suite
When session issue is identified, AUTOMATICALLY create test file:

```
Location: src/__tests__/session-trace.test.ts

Contains:
âœ“ Step A Tests: Verify API returns user
âœ“ Step B Tests: Verify network sends credentials  
âœ“ Step C Tests: Verify frontend state updates

Run: `npm test session-trace.test.ts`
```

---

## ğŸ“‹ 5. DIRECTIVES FOR SPECIFIC FRAMEWORKS

### NextAuth.js
```
Key Files: pages/api/auth/[...nextauth].js

Verify:
âœ“ Providers configured (OAuth, Credentials, etc)
âœ“ Callbacks defined: signIn, redirect, session, jwt
âœ“ JWT strategy OR database session
âœ“ getSession() called on client side
âœ“ useSession() hook in components
âœ“ <SessionProvider> wraps app
```

### Express + Passport
```
Key Files: routes/auth.js, middleware/auth.js

Verify:
âœ“ passport.initialize() before routes
âœ“ Session middleware configured
âœ“ req.user populated after auth
âœ“ res.json({ user: req.user })
âœ“ Credentials sent in fetch
```

### React Context + Custom API
```
Key Files: context/AuthContext.tsx, hooks/useAuth.ts

Verify:
âœ“ Context provider wraps app
âœ“ useEffect fetches current user
âœ“ localStorage saves session
âœ“ useEffect re-fetches on app load
```

### Redux + Redux-Persist
```
Key Files: store.ts, slices/authSlice.ts

Verify:
âœ“ persistor configured in store
âœ“ authSlice updates on login
âœ“ Middleware fetches user on app init
âœ“ localStorage syncs state
```

---

## ğŸ“‹ 6. COMMON PATTERNS & FIXES

### Pattern: Session Not Updating After Login
```
Root Cause: 
- API returns user, but frontend state not updated
- Or: Frontend state updated, but not persisted

Fix:
1. Add useEffect to sync with backend
2. Store in localStorage/sessionStorage
3. Restore on app load from storage
4. Add periodic refresh (optional)
```

### Pattern: Blank Component After Login
```
Root Cause:
- Component renders before state loads
- Conditional render hiding content
- SSR hydration mismatch (Next.js)

Fix:
1. Add loading state
2. Render fallback/skeleton while loading
3. Wrap SSR component in useEffect + mounted check
```

### Pattern: Login Redirect Loop
```
Root Cause:
- Middleware not setting session correctly
- Session verification failing
- Redirect logic incorrect

Fix:
1. Verify Step A (backend returns user)
2. Verify Step B (credentials sent)
3. Verify Step C (frontend receives update)
4. Check redirect conditions
```

---

## ğŸ“‹ 7. DO's and DON'Ts

### âœ… DO:
- Read ENTIRE middleware chain before modifying
- Check storage mechanism (cookies/localStorage/JWT)
- Use Session Trace Protocol (A â†’ B â†’ C)
- Wrap component in useEffect for SSR issues
- Test with mock session data first
- Verify dependency arrays in useEffect
- Generate test suite for session fixes

### âŒ DON'T:
- Use string replacement on component hooks
- Modify session handling without checking storage
- Skip network credential configuration
- Assume state updates without verification
- Apply fixes to multiple components without understanding impact
- Ignore middleware order in Express/NestJS
- Use localStorage without considering privacy/incognito mode

---

## ğŸ“‹ 8. VERIFICATION CHECKLIST

After implementing session/auth fixes, verify:

```
Backend:
  âœ“ API endpoint returns user object
  âœ“ Response includes required fields
  âœ“ No server errors

Network:
  âœ“ Credentials sent in requests
  âœ“ Cookies/headers in both request & response
  âœ“ CORS configured if needed

Frontend:
  âœ“ State management receives data
  âœ“ Data persists on refresh
  âœ“ Components render with user data
  âœ“ Logout clears all data

Tests:
  âœ“ Session trace tests pass
  âœ“ No console errors
  âœ“ All hooks have correct dependencies
```

---

## ğŸš€ QUICK COMMAND

When user says: "Session not updating" or "Login broken"

RESPONSE:
```
1ï¸âƒ£ Framework detected: [NEXTAUTH/EXPRESS/etc]
2ï¸âƒ£ Running Session Trace Protocol...
   âœ“ Step A: Backend check â†’ [PASS/FAIL]
   âœ“ Step B: Network check â†’ [PASS/FAIL]
   âœ“ Step C: Frontend check â†’ [PASS/FAIL]
3ï¸âƒ£ Root cause: [IDENTIFIED]
4ï¸âƒ£ Fixing with AST-safe refactoring...
5ï¸âƒ£ Generating tests...
```

---

**Remember: Always trace from backend â†’ network â†’ frontend. Never assume.**
